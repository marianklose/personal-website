{
  "hash": "48830decd651168f6517f4fc7cadd777",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Coding RUV as THETA in NONMEM\"\ndescription: \"Have you ever been confused why some people use the $THETA block to code their RUV in NONMEM? You are not alone!\"\nauthor:\n  - name: Marian Klose\n    url: https://github.com/marianklose\n    orcid: 0009-0005-1706-6289\ndate: 10-06-2024\ncategories: [RUV, Error, NONMEM] \nimage: preview.jpg\ndraft: true \necho: true\nbibliography: references.bib\nexecute:\n  echo: true\n  message: false\n  warning: false\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-tools: true\n    number-sections: true\n    embed-resources: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(ggplot2)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(kableExtra)\n```\n:::\n\n\n\nWhen I've started my PhD in pharmacometrics, a colleague of mine sent me a reference model which contained a yet unknown way of specifying the residual unexplained variability (RUV) in NONMEM. So far, I was always modeling the RUV in the *classical* way (if you can call it like this) by specifying it directly in the \\$SIGMA block. Until this point, I have never thought about another way of doing so. The way I was used to model it looked like this:\n\n``` r\n$ERROR\nY = F + EPS(1)\n\n$SIGMA\n0.23\n```\n\nIn this additive model the initial estimate for the *variance* of the RUV is 0.23. It is quite important, that it is the variance which we are specifying withing the \\$SIGMA (and also \\$OMEGA) block, because units are an important part of this post. The reference model from my colleague, however, looked like this:\n\n``` r\n$THETA\n0.23        ; W \n\n$ERROR\nY = F + W * EPS(1)\n\n$SIGMA\n1 FIX\n```\n\nThe colleague called it the *Uppsala way* of coding things. At the first glance I was quite confused and left with some questions:\n\n-   Why would we fix the RUV in the \\$SIGMA block to 1?\n-   Why does it make sense to specify some sort of scaling parameter W in the \\$THETA block?\n-   How should we interpret the output from this? What's the unit of W?\n\nLet's try to shed some light into the darkness.\n\n## Some theory\n\nLet's stick to the *Uppsala way* of coding the RUV and try to understand what is going on. Most of this theory can also be found in [@proost2017]. `EPS(1)` is a random variable drawn from a normal distribution with a mean of 0 and a variance of 1. You could write:\n\n$$EPS(1) \\sim \\mathcal{N}(0,1)$$\n\nSome people also call this a standard normal distribution. To me it helps to quickly visualize the distribution by sampling from a standard normal distribution (mean = 0, variance = 1):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample from standard normal distribution\nx <- rnorm(100000, mean = 0, sd = 1)\nstd_norm <- tibble(x = x, source = \"unscaled\")\n\n# plot\nstd_norm |> \n  ggplot(aes(x = x, fill = source)) +\n  geom_density(alpha=0.2)+\n  labs(title = \"Standard normal distribution\", x = \"EPS(1)\", y = \"Density\")+\n  scale_fill_manual(\n    \"Source\",\n    values = c(\n      \"unscaled\" = \"#003049\"\n    )\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nBut what happens now if we multiply this random variable with some scaling parameter W? Let's find out:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply with W\nW <- 0.23\nx_scaled <- x * W\nstd_norm_scaled <- tibble(x = x_scaled, source = \"scaled\")\n\n# combine both\nstd_norm_combined <- bind_rows(std_norm, std_norm_scaled)\n\n# plot\nstd_norm_combined |> \n  ggplot(aes(x = x, fill = source)) +\n  geom_density(alpha = 0.2)+\n  labs(title = \"Normal distributions\", x = \"W * EPS(1)\", y = \"Density\")+\n  scale_fill_manual(\n    \"Source\",\n    values = c(\n      \"unscaled\" = \"#003049\",  # Blue color for original\n      \"scaled\" = \"#c1121f\"     # Orange color for scaled\n    )\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nLet's compare the standard deviation and variance of both distributions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summarize data and calculate sd and variance\nstd_norm_combined |> \n  group_by(source) |>   \n  summarize(\n    sd = sd(x),\n    var = var(x)\n  ) |> \n  kbl() |> kable_styling()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> source </th>\n   <th style=\"text-align:right;\"> sd </th>\n   <th style=\"text-align:right;\"> var </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> scaled </td>\n   <td style=\"text-align:right;\"> 0.2304564 </td>\n   <td style=\"text-align:right;\"> 0.0531102 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> unscaled </td>\n   <td style=\"text-align:right;\"> 1.0019845 </td>\n   <td style=\"text-align:right;\"> 1.0039728 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}